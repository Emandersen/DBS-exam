\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{booktabs}

% Page setup
\geometry{margin=2.5cm}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

% Title information
\title{DBS Exam Notes}
\author{}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Functional Dependencies}

\subsection{The "Boss and Follower" Logic}
A functional dependency $\alpha \to \beta$ is a rule stating that if two rows have the same value for the "Boss" ($\alpha$), they \textbf{must} have the same value for the "Follower" ($\beta$).

\subsubsection*{Case Study: Slide 16 Instance}
Based on the table instance provided on Slide 16 of Lecture 7, here is the verification for each functional dependency using the step-by-step process:

\begin{center}
\begin{tabular}{@{}cccc@{}}
\toprule
\textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} \\ \midrule
a1 & b1 & c1 & d1 \\
a2 & b2 & c2 & d2 \\
a2 & b2 & c2 & d3 \\
a3 & b1 & c3 & d3 \\ \bottomrule
\end{tabular}
\end{center}

\subsection{Verification Results}

\begin{itemize}
    \item \textbf{$A \to B$ (Holds):}
    \begin{enumerate}
        \item \textbf{Step-by-Step Check:} Identify the Boss ($A$) and Follower ($B$).
        \item \textbf{Find Duplicates:} Look for rows where the Boss ($A$) has the same value.
        \item \textbf{Check Followers:} For each duplicate Boss, verify that the Follower ($B$) values are identical.
        \item \textbf{Verification:} The only duplicate "Boss" in column $A$ is \textbf{a2} (rows 2 and 3).
        \item \textbf{Verdict:} In both rows, the "Follower" in column $B$ is \textbf{b2}. Since the followers are identical for the duplicate boss, the dependency holds.
    \end{enumerate}

    \item \textbf{$A \to C$ (Holds):}
    \begin{itemize}
        \item For the duplicate boss \textbf{a2}, both rows have the identical follower \textbf{c2} in column $C$.
    \end{itemize}

    \item \textbf{$A \to D$ (Fails):}
    \begin{itemize}
        \item For the duplicate boss \textbf{a2}, the followers in column $D$ are \textbf{d2} and \textbf{d3}.
        \item Because the followers are different for the same boss, the dependency is broken.
    \end{itemize}
\end{itemize}

\section{Finding Superkeys}

\subsection{Step-by-Step Process}
\begin{enumerate}
    \item Start with a candidate attribute (e.g., $B$)
    \item Check if $B$ is a "Boss" for any functional dependency rules
    \item If $B \to A$, your set becomes $\{B, A\}$
    \item Continue using your new set to unlock more attributes
    \item If $\{A, B\}$ is now in your set and $AB \to C$, you add $C$
    \item If you reach all attributes $\{A, B, C, D, E, F\}$, it is a superkey
\end{enumerate}

\section{Normal Form Audit}

\subsection{BCNF Check}
\begin{itemize}
    \item Look at every functional dependency
    \item Is the "Boss" (left side) a superkey?
    \item If even one is not, it is \textbf{NOT in BCNF}
\end{itemize}

\subsection{3NF Check}
\begin{itemize}
    \item If BCNF fails, check the "Follower" (right side)
    \item Is it a prime attribute (part of any candidate key)?
    \item If yes, it is \textbf{3NF}
\end{itemize}

\section{Lossless Join}

A split into $R_1$ and $R_2$ is \textbf{lossless} if the attributes they share are a superkey for at least one of the two resulting tables.

\section{External Merge Sort: 2-Way Algorithm}

\subsection{Problem Example}
The answer to Question 6.1 is $\lceil \log_2 2{,}000 \rceil$ because the algorithm must first convert the raw data into manageable pages and then iteratively merge those pages until they are sorted.

\subsection{Step-by-Step Breakdown}

\subsubsection*{Step 1: Calculate the Number of Pages ($B$)}
The algorithm operates on pages (blocks), not individual records.
\begin{itemize}
    \item Total Tuples ($n_{r1}$): 100,000
    \item Tuples per Page: 50
    \item Total Pages ($B$): $\frac{100{,}000}{50} = 2{,}000$ pages
\end{itemize}

\subsubsection*{Step 2: Understand the Sorting Phases}
External sorting is divided into two distinct phases:
\begin{itemize}
    \item \textbf{Phase 1 (Pass 0):} The database reads each page into memory, sorts it, and writes it back to disk. This creates 2,000 sorted runs, each consisting of 1 page.
    \item \textbf{Phase 2 (The Merge Phase):} This is what the question specifically asks for. In this phase, the algorithm takes the sorted runs and merges them into larger and larger runs.
\end{itemize}

\subsubsection*{Step 3: Apply the 2-Way Merge Logic}
In a 2-Way merge, the computer uses 3 buffer pages: two for input (to read two runs) and one for output (to write the merged result).

\textbf{The Power of 2:} Because it is a "2-Way" merge, it combines 2 runs into 1 larger run during every pass.
\begin{itemize}
    \item Pass 1: 2,000 runs are merged into 1,000 runs
    \item Pass 2: 1,000 runs are merged into 500 runs
    \item \textbf{Goal:} This continues until only 1 single sorted run remains
\end{itemize}

\subsubsection*{Step 4: The Mathematical Formula}
To find out how many times you must halve the number of runs to reach 1, you use a logarithm with base 2.

\textbf{Formula for Phase 2 Passes:} $\lceil \log_2 (\text{Initial Runs}) \rceil$

Since Phase 1 produced 2,000 runs, Phase 2 requires $\lceil \log_2 2{,}000 \rceil$ passes.

\subsection{Why the Other Options Are Wrong}
\begin{itemize}
    \item \textbf{(a) $\lceil \log_2 100{,}000 \rceil$:} This uses the number of tuples, but the database sorts pages.
    \item \textbf{(c) \& (d):} These use a base of 299 ($M-1$), which is the formula for a Multi-Way Merge Sort using all 300 buffer pages, but the question explicitly asked for the 2-Way algorithm.
\end{itemize}

\section{Multi-Way External Merge Sort}

For Multi-Way External Merge Sort, the logic shifts from merging only two runs at a time to using almost all available buffer pages to merge as many runs as possible in a single pass.

\subsection{Example: Using Relation $r_1$}
Using the same relation $r_1$ from Question 6.1 (with 2,000 pages and 300 buffer pages) as an example:

\subsubsection*{1. Calculate Initial Runs (Phase 1 / Pass 0)}
\begin{itemize}
    \item Total Pages ($B$): 2,000
    \item Buffer Pages ($M$): 300
    \item In Phase 1, we read $M$ pages at a time, sort them in memory, and write them out as a "run"
    \item \textbf{Number of Initial Runs:} $\lceil B / M \rceil = \lceil 2{,}000 / 300 \rceil = \mathbf{7 \text{ runs}}$
\end{itemize}

\subsubsection*{2. The Multi-Way Merge Logic (Phase 2)}
In a Multi-Way merge, you use $M - 1$ buffer pages as input buffers (to read from $M - 1$ different runs simultaneously) and 1 page as an output buffer.
\begin{itemize}
    \item \textbf{Fan-in ($M - 1$):} $300 - 1 = \mathbf{299}$. This means you can merge up to 299 runs into 1 larger run in a single pass.
\end{itemize}

\subsubsection*{3. The Mathematical Formula}
To find the number of passes required in Phase 2 to reach a single sorted file, use the formula:
$$\lceil \log_{M-1} (B/M) \rceil$$

\subsubsection*{4. Applying it to the Example}
\begin{itemize}
    \item \textbf{Phase 1 Cost:} $2 \times B = 4{,}000$ I/Os (reading and writing all pages once)
    \item \textbf{Phase 2 Passes:} $\lceil \log_{299} (7) \rceil$. Since 7 is much smaller than 299, it only takes 1 pass to merge all runs into the final sorted file.
    \item \textbf{Total I/O Cost:} $2 \times B \times (1 + \text{number of passes in Phase 2})$. For this specific case: $2 \times 2{,}000 \times (1 + 1) = 8{,}000$ I/Os.
\end{itemize}

\subsection{Quick Comparison}

\begin{center}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Feature} & \textbf{2-Way Merge Sort} & \textbf{Multi-Way Merge Sort ($M$ buffers)} \\ \midrule
Initial Runs & $B$ (each run is 1 page) & $\lceil B / M \rceil$ (each run is $M$ pages) \\
Merge Fan-in & 2 (merges 2 runs at a time) & $M - 1$ (merges many runs at once) \\
Passes Formula & $\lceil \log_2 B \rceil$ & $1 + \lceil \log_{M-1} (B/M) \rceil$ \\ \bottomrule
\end{tabular}
\end{center}

\section{Page-Oriented Nested-Loop Joins}

\subsection{Task-by-Task Logic}
Based on the formula for page-oriented nested-loop joins, follow these steps:

\subsubsection*{Identify the Page Counts ($B$)}
\begin{itemize}
    \item Relation $r_1$: 100,000 tuples / 50 tuples per page = 2,000 pages
    \item Relation $r_2$: 500,000 tuples / 10 tuples per page = 50,000 pages
\end{itemize}

\subsubsection*{Define the Roles}
\begin{itemize}
    \item \textbf{Outer Relation ($R$):} $r_1$ (2,000 pages)
    \item \textbf{Inner Relation ($S$):} $r_2$ (50,000 pages)
\end{itemize}

\subsubsection*{Apply the Cost Formula}
\begin{itemize}
    \item In a page-oriented nested-loop join, the outer relation is read exactly once.
    \item For every page in the outer relation, the entire inner relation must be scanned once.
    \item \textbf{Formula:} $Cost = \text{Pages}_{outer} + (\text{Pages}_{outer} \times \text{Pages}_{inner})$
\end{itemize}

\section{Selection Size Estimation}

When estimating the result size of selection queries, we need to understand several key parameters:

\begin{itemize}
    \item \textbf{$n_r$:} The total number of tuples (rows) in the relation $r$. For example, $n_r = 4{,}000$.
    \item \textbf{$V(A, r)$:} The number of distinct values for attribute $A$ in relation $r$. For instance, $V(A, r) = 100$, $V(B, r) = 200$, and $V(C, r) = 40$.
    \item \textbf{$[\min, \max]$:} The range of possible values for an attribute. For example, attribute $B$ ranges from $20$ to $60$.
\end{itemize}

\subsection{How to Calculate the Selections}

\subsubsection*{1. Equality Selection ($\sigma_{A=v}(r)$)}

\textbf{Logic:} If values are uniformly distributed, every distinct value is expected to appear the same number of times.

\textbf{Formula:} $\text{Estimated Size} = \frac{n_r}{V(A, r)}$

\textbf{Example:} $\sigma_{A=50}(r)$
\begin{itemize}
    \item Calculation: $4{,}000 / 100 = 40$
    \item Verdict: If a statement says the estimation is 100, it would be False.
\end{itemize}

\subsubsection*{2. Range Selection ($\sigma_{A < v}(r)$ or $\sigma_{A > v}(r)$)}

\textbf{Logic:} You calculate the "fraction" of the range that is covered by the query and multiply it by the total number of tuples.

\textbf{Formula:} $\text{Estimated Size} = n_r \times \frac{v - \min(A)}{\max(A) - \min(A)}$

\textbf{Example:} $\sigma_{A < 50}(r)$ where range for $A$ is $[0, 100]$
\begin{itemize}
    \item Calculation: $4{,}000 \times \frac{50 - 0}{100 - 0} = 4{,}000 \times 0.5 = 2{,}000$
\end{itemize}

\subsection{Verifying Multiple Options}

\textbf{Option (a):} $\sigma_{C=150}(r)$
\begin{itemize}
    \item Calculation: $n_r / V(C, r) = 4{,}000 / 40 = 100$
    \item Verdict: If a statement says the estimation is 100, it is True.
\end{itemize}

\textbf{Option (e):} $\sigma_{B < 30}(r)$ where range for $B$ is $[20, 60]$
\begin{itemize}
    \item Calculation: $4{,}000 \times \frac{30 - 20}{60 - 20} = 4{,}000 \times \frac{10}{40} = 4{,}000 \times 0.25 = 1{,}000$
    \item Verdict: If a statement says the estimation is 1,000, it is True.
\end{itemize}

\subsection{Summary Table}

\begin{center}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Type of Query} & \textbf{Formula} \\ \midrule
Equality ($A = v$) & $\frac{n_r}{V(A, r)}$ \\
Range ($A < v$) & $n_r \times \frac{v - \min}{\max - \min}$ \\
Range ($A > v$) & $n_r \times \frac{\max - v}{\max - \min}$ \\ \bottomrule
\end{tabular}
\end{center}

\end{document}
