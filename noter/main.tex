\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath,amssymb}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{tcolorbox}
\tcbuselibrary{skins,breakable}

% Page setup
\geometry{margin=2.5cm}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

% Define custom colors
\definecolor{sectioncolor}{RGB}{0,102,204}
\definecolor{subsectioncolor}{RGB}{0,153,153}
\definecolor{examplebox}{RGB}{230,240,255}
\definecolor{formulabox}{RGB}{255,248,220}
\definecolor{importantbox}{RGB}{255,230,230}

% Title information
\title{\color{sectioncolor}\textbf{DBS Exam Notes}}
\author{}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{\color{sectioncolor}\color{sectioncolor}Functional Dependencies}

\subsection{\color{subsectioncolor}The "Boss and Follower" Logic}

\begin{tcolorbox}[colback=formulabox,colframe=orange,title=\textbf{Key Rule}]
A functional dependency $\alpha \to \beta$ is a rule stating that if two rows have the same value for the "Boss" ($\alpha$), they \textbf{must} have the same value for the "Follower" ($\beta$).
\end{tcolorbox}

\subsubsection*{Case Study: Slide 16 Instance}
Based on the table instance provided on Slide 16 of Lecture 7, here is the verification for each functional dependency using the step-by-step process:

\begin{center}
\begin{tabular}{@{}cccc@{}}
\toprule
\textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} \\ \midrule
a1 & b1 & c1 & d1 \\
a2 & b2 & c2 & d2 \\
a2 & b2 & c2 & d3 \\
a3 & b1 & c3 & d3 \\ \bottomrule
\end{tabular}
\end{center}

\subsection{\color{subsectioncolor}Verification Results}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{Step-by-Step Verification}]
\begin{itemize}
    \item \textbf{\color{blue}$A \to B$ (Holds):}
    \begin{enumerate}
        \item \textbf{Step-by-Step Check:} Identify the Boss ($A$) and Follower ($B$).
        \item \textbf{Find Duplicates:} Look for rows where the Boss ($A$) has the same value.
        \item \textbf{Check Followers:} For each duplicate Boss, verify that the Follower ($B$) values are identical.
        \item \textbf{Verification:} The only duplicate "Boss" in column $A$ is \textbf{a2} (rows 2 and 3).
        \item \textbf{Verdict:} In both rows, the "Follower" in column $B$ is \textbf{b2}. Since the followers are identical for the duplicate boss, the dependency holds.
    \end{enumerate}

    \item \textbf{\color{blue}$A \to C$ (Holds):}
    \begin{itemize}
        \item For the duplicate boss \textbf{a2}, both rows have the identical follower \textbf{c2} in column $C$.
    \end{itemize}

    \item \textbf{\color{red}$A \to D$ (Fails):}
    \begin{itemize}
        \item For the duplicate boss \textbf{a2}, the followers in column $D$ are \textbf{d2} and \textbf{d3}.
        \item Because the followers are different for the same boss, the dependency is broken.
    \end{itemize}
\end{itemize}
\end{tcolorbox}

\newpage
\section{\color{sectioncolor}Finding Superkeys}

\subsection{\color{subsectioncolor}Step-by-Step Process}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{How to Find Superkeys}]
\begin{enumerate}
    \item Start with a candidate attribute (e.g., $B$)
    \item Check if $B$ is a "Boss" for any functional dependency rules
    \item If $B \to A$, your set becomes $\{B, A\}$
    \item Continue using your new set to unlock more attributes
    \item If $\{A, B\}$ is now in your set and $AB \to C$, you add $C$
    \item If you reach all attributes $\{A, B, C, D, E, F\}$, it is a superkey
\end{enumerate}
\end{tcolorbox}

\newpage
\section{\color{sectioncolor}Normal Form Audit}

\subsection{\color{subsectioncolor}BCNF Check}

\begin{tcolorbox}[colback=importantbox,colframe=red,title=\textbf{BCNF Rule}]
\begin{itemize}
    \item Look at every functional dependency
    \item Is the "Boss" (left side) a superkey?
    \item If even one is not, it is \textbf{NOT in BCNF}
\end{itemize}
\end{tcolorbox}

\subsection{\color{subsectioncolor}3NF Check}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{3NF Rule}]
\begin{itemize}
    \item If BCNF fails, check the "Follower" (right side)
    \item Is it a prime attribute (part of any candidate key)?
    \item If yes, it is \textbf{3NF}
\end{itemize}
\end{tcolorbox}

\newpage
\section{\color{sectioncolor}Lossless Join}

\begin{tcolorbox}[colback=formulabox,colframe=orange,title=\textbf{\color{orange}Formula: Lossless Join}]
A split into $R_1$ and $R_2$ is \textbf{lossless} if the attributes they share are a superkey for at least one of the two resulting tables.
\end{tcolorbox}

\newpage
\section{\color{sectioncolor}External Merge Sort: 2-Way Algorithm}

\subsection{\color{subsectioncolor}Problem Example}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{Example: Question 6.1}]
The answer to Question 6.1 is $\lceil \log_2 2{,}000 \rceil$ because the algorithm must first convert the raw data into manageable pages and then iteratively merge those pages until they are sorted.
\end{tcolorbox}

\subsection{\color{subsectioncolor}Step-by-Step Breakdown}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{How to Calculate Pages and Phases}]
\subsubsection*{Step 1: Calculate the Number of Pages ($B$)}
The algorithm operates on pages (blocks), not individual records.
\begin{itemize}
    \item Total Tuples ($n_{r1}$): 100,000
    \item Tuples per Page: 50
    \item Total Pages ($B$): $\frac{100{,}000}{50} = 2{,}000$ pages
\end{itemize}

\subsubsection*{Step 2: Understand the Sorting Phases}
External sorting is divided into two distinct phases:
\begin{itemize}
    \item \textbf{Phase 1 (Pass 0):} The database reads each page into memory, sorts it, and writes it back to disk. This creates 2,000 sorted runs, each consisting of 1 page.
    \item \textbf{Phase 2 (The Merge Phase):} This is what the question specifically asks for. In this phase, the algorithm takes the sorted runs and merges them into larger and larger runs.
\end{itemize}

\subsubsection*{Step 3: Apply the 2-Way Merge Logic}
In a 2-Way merge, the computer uses 3 buffer pages: two for input (to read two runs) and one for output (to write the merged result).

\textbf{The Power of 2:} Because it is a "2-Way" merge, it combines 2 runs into 1 larger run during every pass.
\begin{itemize}
    \item Pass 1: 2,000 runs are merged into 1,000 runs
    \item Pass 2: 1,000 runs are merged into 500 runs
    \item \textbf{Goal:} This continues until only 1 single sorted run remains
\end{itemize}
\end{tcolorbox}

\subsubsection*{Step 4: The Mathematical Formula}
To find out how many times you must halve the number of runs to reach 1, you use a logarithm with base 2.

\textbf{Formula for Phase 2 Passes:} $\lceil \log_2 (\text{Initial Runs}) \rceil$

Since Phase 1 produced 2,000 runs, Phase 2 requires $\lceil \log_2 2{,}000 \rceil$ passes.

\subsection{\color{subsectioncolor}Why the Other Options Are Wrong}

\begin{tcolorbox}[colback=importantbox,colframe=red,title=\textbf{Common Mistakes}]
\begin{itemize}
    \item \textbf{(a) $\lceil \log_2 100{,}000 \rceil$:} This uses the number of tuples, but the database sorts pages.
    \item \textbf{(c) \& (d):} These use a base of 299 ($M-1$), which is the formula for a Multi-Way Merge Sort using all 300 buffer pages, but the question explicitly asked for the 2-Way algorithm.
\end{itemize}
\end{tcolorbox}

\section{\color{sectioncolor}Multi-Way External Merge Sort}

For Multi-Way External Merge Sort, the logic shifts from merging only two runs at a time to using almost all available buffer pages to merge as many runs as possible in a single pass.

\subsection{\color{subsectioncolor}Example: Using Relation $r_1$}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{Worked Example}]
Using the same relation $r_1$ from Question 6.1 (with 2,000 pages and 300 buffer pages) as an example:

\subsubsection*{1. Calculate Initial Runs (Phase 1 / Pass 0)}
\begin{itemize}
    \item Total Pages ($B$): 2,000
    \item Buffer Pages ($M$): 300
    \item In Phase 1, we read $M$ pages at a time, sort them in memory, and write them out as a "run"
    \item \textbf{Number of Initial Runs:} $\lceil B / M \rceil = \lceil 2{,}000 / 300 \rceil = \mathbf{7 \text{ runs}}$
\end{itemize}

\subsubsection*{2. The Multi-Way Merge Logic (Phase 2)}
In a Multi-Way merge, you use $M - 1$ buffer pages as input buffers (to read from $M - 1$ different runs simultaneously) and 1 page as an output buffer.
\begin{itemize}
    \item \textbf{Fan-in ($M - 1$):} $300 - 1 = \mathbf{299}$. This means you can merge up to 299 runs into 1 larger run in a single pass.
\end{itemize}
\end{tcolorbox}

\subsubsection*{3. The Mathematical Formula}
To find the number of passes required in Phase 2 to reach a single sorted file, use the formula:

\begin{tcolorbox}[colback=formulabox,colframe=orange,title=\textbf{\color{orange}Formula: Multi-Way Merge}]
$$\lceil \log_{M-1} (B/M) \rceil$$
\end{tcolorbox}

\subsubsection*{4. Applying it to the Example}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{Calculation}]
\begin{itemize}
    \item \textbf{Phase 1 Cost:} $2 \times B = 4{,}000$ I/Os (reading and writing all pages once)
    \item \textbf{Phase 2 Passes:} $\lceil \log_{299} (7) \rceil$. Since 7 is much smaller than 299, it only takes 1 pass to merge all runs into the final sorted file.
    \item \textbf{Total I/O Cost:} $2 \times B \times (1 + \text{number of passes in Phase 2})$. For this specific case: $2 \times 2{,}000 \times (1 + 1) = 8{,}000$ I/Os.
\end{itemize}
\end{tcolorbox}

\subsection{\color{subsectioncolor}Quick Comparison}

\begin{center}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Feature} & \textbf{2-Way Merge Sort} & \textbf{Multi-Way Merge Sort ($M$ buffers)} \\ \midrule
Initial Runs & $B$ (each run is 1 page) & $\lceil B / M \rceil$ (each run is $M$ pages) \\
Merge Fan-in & 2 (merges 2 runs at a time) & $M - 1$ (merges many runs at once) \\
Passes Formula & $\lceil \log_2 B \rceil$ & $1 + \lceil \log_{M-1} (B/M) \rceil$ \\ \bottomrule
\end{tabular}
\end{center}

\newpage
\section{\color{sectioncolor}Page-Oriented Nested-Loop Joins}

\subsection{\color{subsectioncolor}Task-by-Task Logic}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{How to Calculate Join Cost}]
Based on the formula for page-oriented nested-loop joins, follow these steps:

\subsubsection*{Identify the Page Counts ($B$)}
\begin{itemize}
    \item Relation $r_1$: 100,000 tuples / 50 tuples per page = 2,000 pages
    \item Relation $r_2$: 500,000 tuples / 10 tuples per page = 50,000 pages
\end{itemize}

\subsubsection*{Define the Roles}
\begin{itemize}
    \item \textbf{Outer Relation ($R$):} $r_1$ (2,000 pages)
    \item \textbf{Inner Relation ($S$):} $r_2$ (50,000 pages)
\end{itemize}

\subsubsection*{Apply the Cost Formula}
\begin{itemize}
    \item In a page-oriented nested-loop join, the outer relation is read exactly once.
    \item For every page in the outer relation, the entire inner relation must be scanned once.
\end{itemize}

\begin{tcolorbox}[colback=formulabox,colframe=orange,title=\textbf{\color{orange}Formula: Nested-Loop Join Cost}]
$$Cost = \text{Pages}_{outer} + (\text{Pages}_{outer} \times \text{Pages}_{inner})$$
\end{tcolorbox}
\end{tcolorbox}

\newpage
\section{\color{sectioncolor}Selection Size Estimation}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{Key Parameters}]
When estimating the result size of selection queries, we need to understand several key parameters:

\begin{itemize}
    \item \textbf{$n_r$:} The total number of tuples (rows) in the relation $r$. For example, $n_r = 4{,}000$.
    \item \textbf{$V(A, r)$:} The number of distinct values for attribute $A$ in relation $r$. For instance, $V(A, r) = 100$, $V(B, r) = 200$, and $V(C, r) = 40$.
    \item \textbf{$[\min, \max]$:} The range of possible values for an attribute. For example, attribute $B$ ranges from $20$ to $60$.
\end{itemize}
\end{tcolorbox}

\subsection{\color{subsectioncolor}How to Calculate the Selections}

\subsubsection*{1. Equality Selection ($\sigma_{A=v}(r)$)}

\begin{tcolorbox}[colback=formulabox,colframe=orange,title=\textbf{\color{orange}Formula: Equality Selection}]
\textbf{Logic:} If values are uniformly distributed, every distinct value is expected to appear the same number of times.

\textbf{\color{orange}Formula:} $\text{Estimated Size} = \frac{n_r}{V(A, r)}$
\end{tcolorbox}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{Example}]
\textbf{Example:} $\sigma_{A=50}(r)$
\begin{itemize}
    \item Calculation: $4{,}000 / 100 = 40$
    \item Verdict: If a statement says the estimation is 100, it would be False.
\end{itemize}
\end{tcolorbox}

\subsubsection*{2. Range Selection ($\sigma_{A < v}(r)$ or $\sigma_{A > v}(r)$)}

\begin{tcolorbox}[colback=formulabox,colframe=orange,title=\textbf{\color{orange}Formula: Range Selection}]
\textbf{Logic:} You calculate the "fraction" of the range that is covered by the query and multiply it by the total number of tuples.

\textbf{\color{orange}Formula:} $\text{Estimated Size} = n_r \times \frac{v - \min(A)}{\max(A) - \min(A)}$
\end{tcolorbox}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{Example}]
\textbf{Example:} $\sigma_{A < 50}(r)$ where range for $A$ is $[0, 100]$
\begin{itemize}
    \item Calculation: $4{,}000 \times \frac{50 - 0}{100 - 0} = 4{,}000 \times 0.5 = 2{,}000$
\end{itemize}
\end{tcolorbox}

\subsection{\color{subsectioncolor}Verifying Multiple Options}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{More Examples}]
\textbf{Option (a):} $\sigma_{C=150}(r)$
\begin{itemize}
    \item Calculation: $n_r / V(C, r) = 4{,}000 / 40 = 100$
    \item Verdict: If a statement says the estimation is 100, it is True.
\end{itemize}

\textbf{Option (e):} $\sigma_{B < 30}(r)$ where range for $B$ is $[20, 60]$
\begin{itemize}
    \item Calculation: $4{,}000 \times \frac{30 - 20}{60 - 20} = 4{,}000 \times \frac{10}{40} = 4{,}000 \times 0.25 = 1{,}000$
    \item Verdict: If a statement says the estimation is 1,000, it is True.
\end{itemize}
\end{tcolorbox}

\subsection{\color{subsectioncolor}Summary Table}

\begin{center}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Type of Query} & \textbf{Formula} \\ \midrule
Equality ($A = v$) & $\frac{n_r}{V(A, r)}$ \\
Range ($A < v$) & $n_r \times \frac{v - \min}{\max - \min}$ \\
Range ($A > v$) & $n_r \times \frac{\max - v}{\max - \min}$ \\ \bottomrule
\end{tabular}
\end{center}

\newpage
\section{\color{sectioncolor}B+ Tree Operations}

\subsection{\color{subsectioncolor}Insertion (Handling Overflow)}

\begin{tcolorbox}[colback=importantbox,colframe=red,title=\textbf{What is Overflow?}]
When you insert a key into a leaf node that is already full (contains $d-1$ keys), an overflow occurs.
\end{tcolorbox}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{How to Handle Insertion Overflow}]
\textbf{Step 1: Temporary Sort}
\begin{itemize}
    \item Place the new key in the node in its correct sorted order
\end{itemize}

\textbf{Step 2: Split}
\begin{itemize}
    \item Split the node into two parts
\end{itemize}

\textbf{Step 3: Promote}
\begin{itemize}
    \item \textbf{If it is a Leaf Node:} Keep the first $\lceil d/2 \rceil$ keys in the original node and move the remaining keys to a new sibling. Copy the smallest key of the new sibling up to the parent.
    \item \textbf{If it is an Internal Node:} Move the middle key up to the parent and split the remaining keys between the old and new nodes.
\end{itemize}

\textbf{Step 4: Repeat}
\begin{itemize}
    \item If the parent also overflows, repeat the split process upward to the root.
\end{itemize}
\end{tcolorbox}

\subsection{\color{subsectioncolor}Deletion (Handling Underflow)}

\begin{tcolorbox}[colback=importantbox,colframe=red,title=\textbf{What is Underflow?}]
A node underflows if its number of keys drops below the required minimum:
\begin{itemize}
    \item \textbf{Leaf Minimum:} $\lceil (d-1)/2 \rceil$ keys
    \item \textbf{Internal Minimum:} $\lceil d/2 \rceil$ pointers
\end{itemize}
\end{tcolorbox}

\begin{tcolorbox}[colback=examplebox,colframe=blue,title=\textbf{How to Handle Deletion Underflow}]
\textbf{Step 1: Delete}
\begin{itemize}
    \item Find and remove the key from the leaf node
\end{itemize}

\textbf{Step 2: Check for Underflow}
\begin{itemize}
    \item If the node still has enough keys, you are done
    \item If not, proceed to Step 3
\end{itemize}

\textbf{Step 3: Redistribution (Borrowing)}
\begin{itemize}
    \item Check if the immediate left or right sibling has "extra" keys (more than the minimum)
    \item If yes, "borrow" a key from the sibling and update the parent's separator key to reflect the change
\end{itemize}

\textbf{Step 4: Merging (Coalescing)}
\begin{itemize}
    \item If no sibling can spare a key, merge the underfull node with a sibling
    \item This requires removing a separator key from the parent
    \item \textbf{Crucial:} If removing the key from the parent causes the parent to underflow, repeat the redistribution/merging process at the next level up
\end{itemize}
\end{tcolorbox}

\subsection{\color{subsectioncolor}Key Concepts for B+ Trees}

\begin{tcolorbox}[colback=formulabox,colframe=orange,title=\textbf{Important B+ Tree Facts}]
\textbf{Search Path:}
\begin{itemize}
    \item Start at the root. If searching for $K$, follow the left pointer for values $< K$ and the right pointer for values $\ge K$
\end{itemize}

\textbf{Leaf Nodes:}
\begin{itemize}
    \item These are the only nodes that contain actual pointers to the data rows
    \item Internal nodes only contain "signpost" keys
\end{itemize}

\textbf{Efficiency:}
\begin{itemize}
    \item Range queries are efficient because leaf nodes are linked together
    \item You can find the start of a range and simply scan forward
\end{itemize}
\end{tcolorbox}

\end{document}


